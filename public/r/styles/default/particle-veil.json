{
  "name": "particle-veil",
  "type": "registry:ui",
  "files": [
    {
      "path": "ui/particle-veil.tsx",
      "content": "import React, { useEffect, useRef } from \"react\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface ParticleVeilProps\n  extends React.HTMLAttributes<HTMLCanvasElement> {\n  /**\n   * Number of particles to render\n   * @default 100\n   */\n  particleCount?: number;\n  /**\n   * Colors for the particles. If multiple colors are provided, they will be distributed among particles\n   * @default [\"#ffffff\"]\n   */\n  particleColors?: string[];\n  /**\n   * Mouse interaction radius in pixels\n   * @default 100\n   */\n  interactionRadius?: number;\n  /**\n   * Particle movement speed\n   * @default 1\n   */\n  speed?: number;\n  /**\n   * Particle size range [min, max]\n   * @default [1, 3]\n   */\n  sizeRange?: [number, number];\n}\n\ninterface Particle {\n  x: number;\n  y: number;\n  size: number;\n  vx: number;\n  vy: number;\n  baseVx: number;\n  baseVy: number;\n  life: number;\n  color: string;\n}\n\nexport default function ParticleVeil({\n  className,\n  particleCount = 100,\n  particleColors = [\"#ffffff\"],\n  interactionRadius = 100,\n  speed = 1,\n  sizeRange = [1, 3],\n  ...props\n}: ParticleVeilProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const contextRef = useRef<CanvasRenderingContext2D | null>(null);\n  const particlesRef = useRef<Particle[]>([]);\n  const mouseRef = useRef({ x: -1000, y: -1000 });\n  const rafRef = useRef<number>();\n  const dprRef = useRef(1);\n\n  const createParticles = (width: number, height: number) => {\n    return Array.from({ length: particleCount }, () => {\n      const angle = Math.random() * Math.PI * 2;\n      const baseSpeed = speed * (0.5 + Math.random() * 0.5);\n      return {\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: Math.random() * (sizeRange[1] - sizeRange[0]) + sizeRange[0],\n        vx: Math.cos(angle) * baseSpeed,\n        vy: Math.sin(angle) * baseSpeed,\n        baseVx: Math.cos(angle) * baseSpeed,\n        baseVy: Math.sin(angle) * baseSpeed,\n        life: Math.random() * 0.3 + 0.7,\n        color:\n          particleColors[Math.floor(Math.random() * particleColors.length)],\n      };\n    });\n  };\n\n  const draw = () => {\n    const canvas = canvasRef.current;\n    const ctx = contextRef.current;\n    if (!canvas || !ctx) return;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Update and draw particles\n    particlesRef.current.forEach((p) => {\n      // Update position\n      p.x += p.vx;\n      p.y += p.vy;\n\n      // Wrap around edges\n      if (p.x < 0) p.x = canvas.width / dprRef.current;\n      if (p.x > canvas.width / dprRef.current) p.x = 0;\n      if (p.y < 0) p.y = canvas.height / dprRef.current;\n      if (p.y > canvas.height / dprRef.current) p.y = 0;\n\n      // Mouse interaction\n      const dx = mouseRef.current.x - p.x;\n      const dy = mouseRef.current.y - p.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist < interactionRadius) {\n        // Repel from mouse\n        const force = (1 - dist / interactionRadius) * 0.15;\n        p.vx = p.vx * (1 - force) - dx * force;\n        p.vy = p.vy * (1 - force) - dy * force;\n        p.life = Math.min(1, p.life + 0.1);\n      } else {\n        // Return to natural movement\n        p.vx += (p.baseVx - p.vx) * 0.1;\n        p.vy += (p.baseVy - p.vy) * 0.1;\n        p.life = Math.max(0.7, p.life - 0.02);\n      }\n\n      // Draw particle\n      ctx.beginPath();\n      ctx.globalAlpha = p.life;\n      ctx.fillStyle = p.color;\n      ctx.arc(\n        p.x * dprRef.current,\n        p.y * dprRef.current,\n        p.size * dprRef.current,\n        0,\n        Math.PI * 2,\n      );\n      ctx.fill();\n    });\n\n    rafRef.current = requestAnimationFrame(draw);\n  };\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    // Setup canvas context\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n    contextRef.current = ctx;\n\n    // Set canvas size\n    const resizeCanvas = () => {\n      const rect = canvas.getBoundingClientRect();\n      dprRef.current = window.devicePixelRatio || 1;\n\n      canvas.width = rect.width * dprRef.current;\n      canvas.height = rect.height * dprRef.current;\n\n      // Create particles at logical (pre-scaled) coordinates\n      particlesRef.current = createParticles(rect.width, rect.height);\n    };\n\n    // Handle mouse movement\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = canvas.getBoundingClientRect();\n      mouseRef.current = {\n        x: e.clientX - rect.left,\n        y: e.clientY - rect.top,\n      };\n    };\n\n    const handleMouseLeave = () => {\n      mouseRef.current = { x: -1000, y: -1000 };\n    };\n\n    // Initialize\n    resizeCanvas();\n    draw();\n\n    // Event listeners\n    window.addEventListener(\"resize\", resizeCanvas);\n    canvas.addEventListener(\"mousemove\", handleMouseMove);\n    canvas.addEventListener(\"mouseleave\", handleMouseLeave);\n\n    return () => {\n      window.removeEventListener(\"resize\", resizeCanvas);\n      canvas.removeEventListener(\"mousemove\", handleMouseMove);\n      canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n    };\n  }, [particleCount, particleColors, interactionRadius, speed, sizeRange]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={cn(\"h-full w-full\", className)}\n      {...props}\n    />\n  );\n}\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}