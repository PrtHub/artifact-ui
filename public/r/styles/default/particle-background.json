{
  "name": "particle-background",
  "type": "registry:ui",
  "dependencies": [],
  "files": [
    {
      "path": "xanthic/particle-background.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef, useState } from \"react\";\n\ninterface Particle {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  size: number;\n}\n\ninterface ParticleNetworkBackgroundProps {\n  particleCount?: number;\n  particleSize?: number;\n  particleColor?: string;\n  lineColor?: string;\n  maxDistance?: number;\n  speed?: number;\n  className?: string;\n  interactive?: boolean;\n}\n\nexport default function ParticleNetworkBackground({\n  particleCount = 50,\n  particleSize = 2,\n  particleColor = \"#4a90e2\",\n  lineColor = \"rgba(74, 144, 226, 0.2)\",\n  maxDistance = 100,\n  speed = 1,\n  className = \"\",\n  interactive = true,\n}: ParticleNetworkBackgroundProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const particlesRef = useRef<Particle[]>([]);\n  const mousePositionRef = useRef({ x: 0, y: 0 });\n  const isMouseInCanvasRef = useRef(false);\n  const animationFrameId = useRef<number>();\n\n  const initParticles = (width: number, height: number) => {\n    const particles: Particle[] = [];\n    for (let i = 0; i < particleCount; i++) {\n      particles.push({\n        x: Math.random() * width,\n        y: Math.random() * height,\n        vx: (Math.random() - 0.5) * speed,\n        vy: (Math.random() - 0.5) * speed,\n        size: particleSize,\n      });\n    }\n    particlesRef.current = particles;\n  };\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    const updateCanvasSize = () => {\n      const rect = canvas.getBoundingClientRect();\n      canvas.width = rect.width;\n      canvas.height = rect.height;\n      initParticles(rect.width, rect.height);\n    };\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!interactive) return;\n      const rect = canvas.getBoundingClientRect();\n      mousePositionRef.current = {\n        x: e.clientX - rect.left,\n        y: e.clientY - rect.top,\n      };\n    };\n\n    const handleMouseEnter = () => {\n      isMouseInCanvasRef.current = true;\n    };\n\n    const handleMouseLeave = () => {\n      isMouseInCanvasRef.current = false;\n    };\n\n    const animate = () => {\n      const { width, height } = canvas;\n      ctx.clearRect(0, 0, width, height);\n\n      particlesRef.current = particlesRef.current.map((particle) => {\n        particle.x += particle.vx;\n        particle.y += particle.vy;\n\n        if (particle.x < 0 || particle.x > width) particle.vx *= -1;\n        if (particle.y < 0 || particle.y > height) particle.vy *= -1;\n\n        particle.x = Math.max(0, Math.min(width, particle.x));\n        particle.y = Math.max(0, Math.min(height, particle.y));\n\n        ctx.beginPath();\n        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n        ctx.fillStyle = particleColor;\n        ctx.fill();\n\n        return particle;\n      });\n\n      ctx.beginPath();\n      for (let i = 0; i < particlesRef.current.length; i++) {\n        const particle1 = particlesRef.current[i];\n\n        if (interactive && isMouseInCanvasRef.current) {\n          const mouseDistance = Math.hypot(\n            mousePositionRef.current.x - particle1.x,\n            mousePositionRef.current.y - particle1.y,\n          );\n          if (mouseDistance < maxDistance) {\n            ctx.moveTo(particle1.x, particle1.y);\n            ctx.lineTo(mousePositionRef.current.x, mousePositionRef.current.y);\n          }\n        }\n\n        for (let j = i + 1; j < particlesRef.current.length; j++) {\n          const particle2 = particlesRef.current[j];\n          const distance = Math.hypot(\n            particle2.x - particle1.x,\n            particle2.y - particle1.y,\n          );\n\n          if (distance < maxDistance) {\n            ctx.moveTo(particle1.x, particle1.y);\n            ctx.lineTo(particle2.x, particle2.y);\n          }\n        }\n      }\n      ctx.strokeStyle = lineColor;\n      ctx.stroke();\n\n      animationFrameId.current = requestAnimationFrame(animate);\n    };\n\n    updateCanvasSize();\n    window.addEventListener(\"resize\", updateCanvasSize);\n\n    if (interactive) {\n      canvas.addEventListener(\"mousemove\", handleMouseMove);\n      canvas.addEventListener(\"mouseenter\", handleMouseEnter);\n      canvas.addEventListener(\"mouseleave\", handleMouseLeave);\n    }\n\n    animate();\n\n    return () => {\n      window.removeEventListener(\"resize\", updateCanvasSize);\n      if (interactive) {\n        canvas.removeEventListener(\"mousemove\", handleMouseMove);\n        canvas.removeEventListener(\"mouseenter\", handleMouseEnter);\n        canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n      }\n      if (animationFrameId.current) {\n        cancelAnimationFrame(animationFrameId.current);\n      }\n    };\n  }, [\n    particleColor,\n    lineColor,\n    maxDistance,\n    particleCount,\n    particleSize,\n    speed,\n    interactive,\n  ]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={`absolute inset-0 h-full w-full ${className}`}\n      style={{ background: \"transparent\" }}\n    />\n  );\n}\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}