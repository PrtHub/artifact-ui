{
  "name": "swarm-effect",
  "type": "registry:ui",
  "files": [
    {
      "path": "ui/swarm-effect.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport type { StaticImageData } from \"next/image\";\n\nexport interface ParticleImageProps\n  extends React.HTMLAttributes<HTMLDivElement> {\n  src: string | StaticImageData;\n  particleSize?: number;\n  particleSpacing?: number;\n  particleColor?: string;\n  displacementRadius?: number;\n  hoverEffect?: \"scatter\" | \"gather\" | \"none\";\n  className?: string;\n}\n\nexport default function SwarmEffect({\n  src,\n  particleSize = 2,\n  particleSpacing = 4,\n  particleColor = \"hsl(280, 100%, 60%)\",\n  displacementRadius = 50,\n  hoverEffect = \"scatter\",\n  className,\n  ...props\n}: ParticleImageProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [particles, setParticles] = useState<\n    Array<{ x: number; y: number; originX: number; originY: number }>\n  >([]);\n  const [mousePosition, setMousePosition] = useState<{\n    x: number;\n    y: number;\n  } | null>(null);\n  const frameRef = useRef<number>();\n  const imageRef = useRef<HTMLImageElement>();\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\", { willReadFrequently: true });\n    if (!ctx) return;\n\n    const image = new Image();\n    image.crossOrigin = \"anonymous\";\n    image.src = typeof src === \"string\" ? src : src.src;\n    imageRef.current = image;\n\n    image.onload = () => {\n      const tempCanvas = document.createElement(\"canvas\");\n      const tempCtx = tempCanvas.getContext(\"2d\");\n      if (!tempCtx) return;\n\n      const containerWidth = canvas.clientWidth;\n      const containerHeight =\n        canvas.clientHeight || (containerWidth * image.height) / image.width;\n\n      canvas.width = containerWidth;\n      canvas.height = containerHeight;\n\n      tempCanvas.width = containerWidth;\n      tempCanvas.height = containerHeight;\n      tempCtx.drawImage(image, 0, 0, containerWidth, containerHeight);\n\n      const imageData = tempCtx.getImageData(\n        0,\n        0,\n        containerWidth,\n        containerHeight,\n      );\n      const particles: Array<{\n        x: number;\n        y: number;\n        originX: number;\n        originY: number;\n      }> = [];\n\n      for (let y = 0; y < containerHeight; y += particleSpacing) {\n        for (let x = 0; x < containerWidth; x += particleSpacing) {\n          const i = (y * containerWidth + x) * 4;\n          const alpha = imageData.data[i + 3];\n          const brightness =\n            (imageData.data[i] +\n              imageData.data[i + 1] +\n              imageData.data[i + 2]) /\n            3;\n          if (alpha > 128 && brightness > 20) {\n            particles.push({\n              x,\n              y,\n              originX: x,\n              originY: y,\n            });\n          }\n        }\n      }\n\n      setParticles(particles);\n    };\n\n    return () => {\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n    };\n  }, [src, particleSpacing]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || !particles.length) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    const animate = () => {\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.fillStyle = particleColor;\n\n      particles.forEach((particle) => {\n        let dx = 0;\n        let dy = 0;\n\n        if (mousePosition && hoverEffect !== \"none\") {\n          const distance = Math.sqrt(\n            Math.pow(mousePosition.x - particle.x, 2) +\n              Math.pow(mousePosition.y - particle.y, 2),\n          );\n\n          if (distance < displacementRadius) {\n            const force = Math.pow(\n              (displacementRadius - distance) / displacementRadius,\n              1.5,\n            );\n            if (hoverEffect === \"scatter\") {\n              dx = (particle.x - mousePosition.x) * force * 1.2;\n              dy = (particle.y - mousePosition.y) * force * 1.2;\n            } else {\n              dx = (mousePosition.x - particle.x) * force * 1.2;\n              dy = (mousePosition.y - particle.y) * force * 1.2;\n            }\n          }\n        }\n\n        const targetX = particle.originX + dx;\n        const targetY = particle.originY + dy;\n\n        particle.x += (targetX - particle.x) * 0.25;\n        particle.y += (targetY - particle.y) * 0.25;\n\n        ctx.beginPath();\n        ctx.arc(particle.x, particle.y, particleSize, 0, Math.PI * 2);\n        ctx.fill();\n      });\n\n      frameRef.current = requestAnimationFrame(animate);\n    };\n\n    animate();\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = canvas.getBoundingClientRect();\n      setMousePosition({\n        x: ((e.clientX - rect.left) * canvas.width) / rect.width,\n        y: ((e.clientY - rect.top) * canvas.height) / rect.height,\n      });\n    };\n\n    const handleMouseLeave = () => {\n      setMousePosition(null);\n    };\n\n    canvas.addEventListener(\"mousemove\", handleMouseMove);\n    canvas.addEventListener(\"mouseleave\", handleMouseLeave);\n\n    return () => {\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n      canvas.removeEventListener(\"mousemove\", handleMouseMove);\n      canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n    };\n  }, [\n    particles,\n    particleSize,\n    particleColor,\n    displacementRadius,\n    hoverEffect,\n    mousePosition,\n  ]);\n\n  return (\n    <div className={cn(\"relative inline-block\", className)} {...props}>\n      <canvas\n        ref={canvasRef}\n        className=\"h-full w-full max-w-full\"\n        style={{ opacity: particles.length ? 1 : 0 }}\n      />\n      <img\n        src={typeof src === \"string\" ? src : src.src}\n        alt=\"\"\n        className=\"absolute left-0 top-0 h-full w-full opacity-0\"\n        style={{ visibility: \"hidden\" }}\n      />\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}